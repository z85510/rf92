"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var EventBus_1;
Object.defineProperty(exports, "__esModule", { value: true });
exports.EventBus = void 0;
const common_1 = require("@nestjs/common");
const core_1 = require("@nestjs/core");
const rxjs_1 = require("rxjs");
const operators_1 = require("rxjs/operators");
const command_bus_1 = require("./command-bus");
const constants_1 = require("./decorators/constants");
const exceptions_1 = require("./exceptions");
const default_get_event_id_1 = require("./helpers/default-get-event-id");
const default_pubsub_1 = require("./helpers/default-pubsub");
const unhandled_exception_bus_1 = require("./unhandled-exception-bus");
const utils_1 = require("./utils");
let EventBus = EventBus_1 = class EventBus extends utils_1.ObservableBus {
    constructor(commandBus, moduleRef, unhandledExceptionBus) {
        super();
        this.commandBus = commandBus;
        this.moduleRef = moduleRef;
        this.unhandledExceptionBus = unhandledExceptionBus;
        this._logger = new common_1.Logger(EventBus_1.name);
        this.subscriptions = [];
        this.getEventId = default_get_event_id_1.defaultGetEventId;
        this.useDefaultPublisher();
    }
    /**
     * Returns the publisher.
     * Default publisher is `DefaultPubSub` (in memory).
     */
    get publisher() {
        return this._publisher;
    }
    /**
     * Sets the publisher.
     * Default publisher is `DefaultPubSub` (in memory).
     * @param _publisher The publisher to set.
     */
    set publisher(_publisher) {
        this._publisher = _publisher;
    }
    onModuleDestroy() {
        this.subscriptions.forEach((subscription) => subscription.unsubscribe());
    }
    /**
     * Publishes an event.
     * @param event The event to publish.
     */
    publish(event, context) {
        return this._publisher.publish(event, context);
    }
    /**
     * Publishes multiple events.
     * @param events The events to publish.
     */
    publishAll(events, context) {
        if (this._publisher.publishAll) {
            return this._publisher.publishAll(events, context);
        }
        return (events || []).map((event) => this._publisher.publish(event, context));
    }
    bind(handler, id) {
        const stream$ = id ? this.ofEventId(id) : this.subject$;
        const subscription = stream$
            .pipe((0, operators_1.mergeMap)((event) => (0, rxjs_1.defer)(() => Promise.resolve(handler.handle(event))).pipe((0, operators_1.catchError)((error) => {
            const unhandledError = this.mapToUnhandledErrorInfo(event, error);
            this.unhandledExceptionBus.publish(unhandledError);
            this._logger.error(`"${handler.constructor.name}" has thrown an unhandled exception.`, error);
            return (0, rxjs_1.of)();
        }))))
            .subscribe();
        this.subscriptions.push(subscription);
    }
    registerSagas(types = []) {
        const sagas = types
            .map((target) => {
            const metadata = Reflect.getMetadata(constants_1.SAGA_METADATA, target) || [];
            const instance = this.moduleRef.get(target, { strict: false });
            if (!instance) {
                throw new exceptions_1.InvalidSagaException();
            }
            return metadata.map((key) => instance[key].bind(instance));
        })
            .reduce((a, b) => a.concat(b), []);
        sagas.forEach((saga) => this.registerSaga(saga));
    }
    register(handlers = []) {
        handlers.forEach((handler) => this.registerHandler(handler));
    }
    registerHandler(handler) {
        const instance = this.moduleRef.get(handler, { strict: false });
        if (!instance) {
            return;
        }
        const events = this.reflectEvents(handler);
        events.map((event) => this.bind(instance, (0, default_get_event_id_1.defaultReflectEventId)(event)));
    }
    ofEventId(id) {
        return this.subject$.pipe((0, operators_1.filter)((event) => this.getEventId(event) === id));
    }
    registerSaga(saga) {
        if (typeof saga !== 'function') {
            throw new exceptions_1.InvalidSagaException();
        }
        const stream$ = saga(this);
        if (!(stream$ instanceof rxjs_1.Observable)) {
            throw new exceptions_1.InvalidSagaException();
        }
        const subscription = stream$
            .pipe((0, operators_1.filter)((e) => !!e), (0, operators_1.mergeMap)((command) => (0, rxjs_1.defer)(() => this.commandBus.execute(command)).pipe((0, operators_1.catchError)((error) => {
            const unhandledError = this.mapToUnhandledErrorInfo(command, error);
            this.unhandledExceptionBus.publish(unhandledError);
            this._logger.error(`Command handler which execution was triggered by Saga has thrown an unhandled exception.`, error);
            return (0, rxjs_1.of)();
        }))))
            .subscribe();
        this.subscriptions.push(subscription);
    }
    reflectEvents(handler) {
        return Reflect.getMetadata(constants_1.EVENTS_HANDLER_METADATA, handler);
    }
    useDefaultPublisher() {
        this._publisher = new default_pubsub_1.DefaultPubSub(this.subject$);
    }
    mapToUnhandledErrorInfo(eventOrCommand, exception) {
        return {
            cause: eventOrCommand,
            exception,
        };
    }
};
EventBus = EventBus_1 = __decorate([
    (0, common_1.Injectable)(),
    __metadata("design:paramtypes", [command_bus_1.CommandBus,
        core_1.ModuleRef,
        unhandled_exception_bus_1.UnhandledExceptionBus])
], EventBus);
exports.EventBus = EventBus;
